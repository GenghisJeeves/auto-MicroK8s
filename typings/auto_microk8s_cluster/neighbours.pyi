"""
This type stub file was generated by pyright.
"""

import ipaddress
import sqlite3
from collections.abc import Generator
from contextlib import contextmanager
from dataclasses import dataclass
from typing import Any

from cryptography.hazmat.primitives.asymmetric import x25519

logger = ...
SNAP_COMMON = ...
DATABASE_PATH = ...
KEY_PATH = ...
PRIVATE_KEY_PATH = ...
PUBLIC_KEY_PATH = ...
_local = ...

@dataclass
class Neighbour:
    """Data class for storing neighbor information"""

    name: str
    ip_address: ipaddress.IPv4Address | ipaddress.IPv6Address
    public_key: str
    trusted: bool = ...
    id: int | None = ...
    def __post_init__(self) -> None:
        """Ensure ip_address is an IP address object"""
        ...

@contextmanager
def get_db_connection() -> Generator[sqlite3.Connection, None, None]:
    """
    Get a database connection from the pool or create a new one.
    Uses thread-local storage to avoid sharing connections between threads.
    """
    ...

def init_database() -> None:
    """Initialize the database schema if it doesn't exist"""
    ...

def get_generate_key_pair() -> tuple[x25519.X25519PrivateKey, x25519.X25519PublicKey]:
    """
    Generate a new X25519 key pair if it doesn't exist, or load existing one.

    Returns:
        Tuple of (private_key, public_key)
    """
    ...

def get_public_key_base64() -> str:
    """
    Get the local public key as a base64 string.

    Returns:
        Base64 encoded public key string
    """
    ...

def send_secure_message(
    neighbour: Neighbour, message: dict[str, Any]
) -> dict[str, str] | None:
    """
    Securely send a message to a neighbor using X25519 for key exchange
    and ChaCha20-Poly1305 for authenticated encryption.

    Args:
        neighbour: The Neighbour object to send to
        message: Dictionary containing the message to send

    Returns:
        Response message dictionary or None if failed
    """
    ...

def receive_secure_message(
    sender_key_base64: str, nonce_base64: str, ciphertext_base64: str
) -> dict[str, Any] | None:
    """
    Receive and decrypt a secure message from a neighbor.

    Args:
        sender_key_base64: Base64-encoded public key of the sender
        nonce_base64: Base64-encoded nonce
        ciphertext_base64: Base64-encoded encrypted message

    Returns:
        Decrypted message dictionary or None if failed
    """
    ...

def add_neighbour(neighbour: Neighbour) -> int | None:
    """
    Add a new neighbor if a neighbor with the same IP address does not exist.
    If a neighbor with the same IP address exists, do not do anything.
    The old IP must fist be removed before adding a new one.

    Args:
        neighbour: The Neighbour object to add or update

    Returns:
        The ID of the added or updated neighbor
    """
    ...

def set_neighbour_trusted(
    ip_address: str | ipaddress.IPv4Address | ipaddress.IPv6Address, trusted: bool = ...
) -> bool:
    """
    Set the trusted status for a neighbor

    Args:
        ip_address: The IP address of the neighbor
        trusted: Whether to mark as trusted (True) or untrusted (False)

    Returns:
        True if the neighbor was found and updated, False otherwise
    """
    ...

def get_neighbour_by_ip(
    ip_address: str | ipaddress.IPv4Address | ipaddress.IPv6Address,
) -> Neighbour | None:
    """
    Retrieve a neighbor by IP address

    Args:
        ip_address: The IP address to search for

    Returns:
        A Neighbour object if found, None otherwise
    """
    ...

def get_all_neighbours() -> list[Neighbour]:
    """
    Retrieve all stored neighbors

    Returns:
        A list of Neighbour objects
    """
    ...

def get_trusted_neighbours() -> list[Neighbour]:
    """
    Retrieve only trusted neighbors

    Returns:
        A list of trusted Neighbour objects
    """
    ...

def remove_neighbour(
    ip_address: str | ipaddress.IPv4Address | ipaddress.IPv6Address,
) -> bool:
    """
    Remove a neighbor from storage

    Args:
        ip_address: The IP address of the neighbor to remove

    Returns:
        True if a neighbor was removed, False otherwise
    """
    ...

def cleanup_stale_neighbours(max_age_hours: int = ...) -> int:
    """
    Remove neighbors that haven't been seen for a specified time

    Args:
        max_age_hours: Maximum age in hours before a neighbor is considered stale

    Returns:
        Number of removed neighbors
    """
    ...

if __name__ == "__main__":
    my_public_key = ...
    test_neighbour = ...
    all_neighbours = ...
    message = ...
    response = ...
